{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport React from \"react\";\nvar __jsx = React.createElement;\nimport client from '../client';\nimport Link from 'next/link';\nimport { useState, useEffect } from 'react'; // import useSWR from 'swr'\n\nimport styled from 'styled-components';\nimport moment from 'moment';\nimport HeaderLayout from '../components/HeaderLayout';\nimport KeywordTags from '../components/KeywordTags';\nimport '../globalStyles.css';\nvar ListItem = styled.li.withConfig({\n  displayName: \"pages__ListItem\",\n  componentId: \"nuslkc-0\"\n})([\"margin:15px 0 0 15px;padding:10px 15px;font-size:1.75em;border:1px solid var(--primary-darker);\"]);\nvar TagListItem = styled.li.withConfig({\n  displayName: \"pages__TagListItem\",\n  componentId: \"nuslkc-1\"\n})([\"display:inline-block;margin-right:5px;padding:3px 5px;font-size:.5em;background-color:var(--secondary-color);\"]);\nvar DescP = styled.p.withConfig({\n  displayName: \"pages__DescP\",\n  componentId: \"nuslkc-2\"\n})([\"font-size:.85em;\"]);\nvar DateP = styled.p.withConfig({\n  displayName: \"pages__DateP\",\n  componentId: \"nuslkc-3\"\n})([\"font-size:.7em;\"]); // (due to objects being by ref) removes duplicate post objects by converting each post into a JSON string so that they can be compared and filtered using `new Set`, then parsing the final unique array of posts back to a normal array of objects\n\nfunction uniquePostsArray(posts) {\n  return _toConsumableArray(new Set(posts.map(function (postObj) {\n    return JSON.stringify(postObj);\n  }))).map(function (postStr) {\n    return JSON.parse(postStr);\n  });\n}\n\nfunction getTagCountsData(tags) {\n  return _regeneratorRuntime.async(function getTagCountsData$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          return _context2.abrupt(\"return\", Promise.all(tags.map(function _callee(tag) {\n            return _regeneratorRuntime.async(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    _context.next = 2;\n                    return _regeneratorRuntime.awrap(client.fetch(\"\\n                *[ _id == $tagID ]{\\n                    name,\\n                    _id,\\n                    \\\"count\\\": count(\\n                        *[ _type == \\\"post\\\" && $tagID in tags[]._ref ]\\n                    )\\n                }[0]\\n            \", {\n                      tagID: tag._id\n                    }));\n\n                  case 2:\n                    return _context.abrupt(\"return\", _context.sent);\n\n                  case 3:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, null, null, null, Promise);\n          })));\n\n        case 1:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction Index(_ref) {\n  var posts = _ref.posts,\n      tags = _ref.tags;\n\n  // console.log('posts: ', posts)\n  // console.log('tags: ', tags)\n  var _useState = useState(posts),\n      allPosts = _useState[0],\n      setAllPosts = _useState[1];\n\n  var _useState2 = useState([]),\n      filteredPosts = _useState2[0],\n      setFilteredPosts = _useState2[1];\n\n  var _useState3 = useState([]),\n      tagCounts = _useState3[0],\n      setTagCounts = _useState3[1];\n\n  var _useState4 = useState([]),\n      filteredTags = _useState4[0],\n      setFilteredTags = _useState4[1];\n\n  useEffect(function () {\n    getTagCountsData(tags).then(function (tagCounts) {\n      setTagCounts(tagCounts);\n    })[\"catch\"](function (err) {\n      return console.log('error getting tag counts: ', err);\n    });\n  }, []);\n  useEffect(function () {\n    if (filteredTags.length > 0) {\n      var _filteredPosts = [];\n      allPosts.forEach(function (post) {\n        post.tags.forEach(function (tag) {\n          if (filteredTags.includes(tag._id)) {\n            _filteredPosts.push(post);\n          }\n        });\n      });\n      setFilteredPosts(uniquePostsArray(_filteredPosts));\n    } else {\n      setFilteredPosts([]);\n    }\n  }, [filteredTags]);\n\n  function handleTagFilter(e) {\n    var selectedTagID = e.target.id;\n\n    if (selectedTagID === 'clearFilter') {\n      setFilteredTags([]);\n    } else if (!filteredTags.includes(selectedTagID)) {\n      setFilteredTags(function (state) {\n        return [].concat(_toConsumableArray(state), [selectedTagID]);\n      });\n    } else {\n      setFilteredTags(filteredTags.filter(function (tag) {\n        return tag !== selectedTagID;\n      }));\n    }\n  }\n\n  var postsToRender = filteredPosts.length > 0 ? filteredPosts : allPosts;\n  return __jsx(HeaderLayout, null, __jsx(\"h2\", null, \"Tags:\"), __jsx(KeywordTags, {\n    tags: tagCounts,\n    handleTagFilter: handleTagFilter,\n    filteredTags: filteredTags\n  }), __jsx(\"h2\", null, \"Posts:\"), postsToRender.map(function (_ref2) {\n    var _id = _ref2._id,\n        _createdAt = _ref2._createdAt,\n        description = _ref2.description,\n        slug = _ref2.slug,\n        title = _ref2.title,\n        tags = _ref2.tags;\n    return __jsx(ListItem, {\n      key: _id\n    }, __jsx(Link, {\n      href: \"/post/[slug]\",\n      as: \"/post/\".concat(slug.current)\n    }, __jsx(\"a\", null, title)), __jsx(DescP, null, description), __jsx(DateP, null, moment.utc(_createdAt).format(\"LL\")), __jsx(\"ul\", null, tags.map(function (tag) {\n      return __jsx(TagListItem, {\n        key: tag._id\n      }, tag.name);\n    })));\n  }));\n}\n\nexport var __N_SSG = true;\nexport default Index;","map":null,"metadata":{},"sourceType":"module"}